# Finding Mobile Elements with Appium

*Finding UI elements with Appium is more or less the same as finding them with Selenium, but we have access to a different set of locator strategies, which means different selectors to think about, too.*

Now we come to finding mobile UI elements using Appium. In general, finding elements works the same way on mobile as on browsers, but there are some important differences.

Just like with web elements, finding mobile elements is a combination of locator strategies and selectors. Let's take a look at the locator strategies available with Appium for iOS and Android.

First, let's talk about the one strategy which is in common between Selenium and Appium, namely the XPath locator strategy. XPath works the same way on mobile, but the XML documents which act as the basis for the queries are very different. In fact, they are not only different from HTML, they are different from one another. That is to say, if you get the page source of an iOS app and the page source of an Android app, they don't use any of the same XML tags. Why are things this way? Well, neither iOS nor Android really have a page source to begin with. Appium just generates one for us so that we can look at it, and so that we can use XPath queries. For this reason, XPath is not a cross-platform locator strategy. If you write an XPath query for iOS, it will probably not work with Android without modification. There are lots of reasons not to use XPath with Appium if you can help it, but we'll talk about that in a bit.

Next, let's move on to the Accessibility ID locator strategy. This is my preferred locator strategy. What does "Accessibility ID" mean? Well, both iOS and Android have the concept of an Accessibility system, which modifies the way the device works to assist users who might find it difficult to use the device in its default mode. People who have trouble seeing or reading small text, for example, can turn on a device mode where they can navigate views purely by moving their fingers around and having element labels read out to them. Developers can attach these labels to elements when they design apps, to make their apps more accessible. On iOS these labels are called Accessibility Labels, and on Android they're called Content Descriptions.

Eventually Apple realized that people like to do UI tests of applications, and were using Accessibility Label data to assist in their testing. But this is not what Accessibility Labels were designed for. To complicate things, Accessibility Labels are often localized, in other words, they are designed to show up in the language of the user, which is an unnecessary complication for running UI tests unless you're testing localization specifically. So Apple created the concept of an Accessibility ID, which is another string that developers can add, which are not visible to users but only to UI automation processes, like Appium. All this to say, Accessibility IDs are little strings that app developers can assign to elements, and that you can use to find elements with in Appium on iOS.

On Android, there's not this distinction between external and internal accessibility strings. Instead, there's the single concept of Content Description, which is definitely an outward-facing accessibility label. Appium can still find elements by these labels, however. So if you use the Accessibility ID locator strategy, you are finding elements by Accessibility ID on iOS and Content Description on Android.

The great thing about this locator strategy is that it has the potential to be totally cross-platform! If you have an iOS and an Android version of your app, you can develop them in such a way that the equivalent elements for each app have the same Accessibility ID and Content Description. Then you can use the same find element commands regardless of which app you're automating.

The third basic locator strategy is the 'class name' strategy. It basically allows you to do the equivalent of what the 'tag name' strategy allows you to do in Selenium, namely finding elements by their type. There are no such things as tags in mobile apps, since the UI elements are not HTML elements. But the UI elements do belong to certain UI element classes as defined in the iOS or Android SDKs. For example, an Android button has the class name <code>android.widget.Button</code>. When you retrieve the page source for a mobile app, the XML nodes are populated using the UI element class names, so that's a good way to explore the various classes.

The last basic strategy is the 'id' strategy. This one is a bit tricky. It exists primarily for use on the Android platform, because Android elements can be associated with something called an Android ID. This is an internal-only identifier used to refer to elements, though there is no requirement that the ID be unique. Still, Android IDs are a common way for Android developers to refer internally to elements, and Appium allows you to find them using this strategy. But what if you use this strategy on iOS? Well, on iOS this strategy will just do the same thing that the Accessibility ID strategy does--it will look for elements by their accessibility ID. For this reason, to make it clear exactly what your test code is doing, I recommend only using the 'id' strategy for Android.


